/*
Generated by vardist stub generator. Don't change.
*/

#pragma once
//#include "../../meroving/hcomm/include/common.h"
//#include "../../meroving/hcomm/include/hcomm.h"
//#include "../../meroving/hcomm/include/objrepr.h"
//#include "meroving/meroving.h"
//#include "hdivider/hdivider.h"

#include <pthread.h>

class RpcServer_fg 
{
 public: 

	static objrepr_t *int_gen(int64_t a)
	{
		objrepr_t *repr = new objrepr_t;
                char bf[15];
                strcpy(bf, "");
		sprintf(bf, "%d\0", a);
                repr->value = string(bf);
		repr->type = "int";
                //delete a;
		return repr;
	}

	static objrepr_t *float_gen(float *a)
	{
		objrepr_t *repr = new objrepr_t;
		char bf[15];
                strcpy(bf, "");
		sprintf(bf, "%f", *a);
                repr->value = bf;
		repr->type = "float";
		return repr;
	}

	static objrepr_t *char_gen(string *a)
	{
		objrepr_t *repr = new objrepr_t;
		repr->value = *a;
		repr->type = "string";
		return repr;
	}

	static int64_t int_neg(objrepr_t *repr)
	{
                int64_t r;
		sscanf(repr->value.c_str(), "%d", &r);
		delete repr;
		return r;
	}

	static float *float_neg(objrepr_t *repr)
	{
		float *r = new float;
		sscanf(repr->value.c_str(), "%f", r);
		delete repr;
		return r;
	}

	static string *char_neg(objrepr_t *repr)
	{
		string *r = new string;
		*r = repr->value;
		delete repr;
		return r;
	}

   static objrepr_t* string_gen(string obj)
  {
       objrepr_t* ret = new objrepr_t("string", obj);
  return ret;
  }

   static objrepr_t* vec_int_gen(vector<int64_t> *obj)
 {
       objrepr_t* ret = new objrepr_t("vector<int>","");
       for (int i = 0; i<obj->size(); i++) 
	{ 
       ret->fields.push_back(pair<string, objrepr_t*>("int", int_gen(obj->at(i))));
       }
       delete obj;
  return ret;
  }



   static string string_neg(objrepr_t* repr)
    {
       string ret;
       ret = repr->value;
       delete repr;
          return ret;
  }

   static vector<InputId>* vec_int_neg(objrepr_t *repr)
	{
       vector<InputId>* ret = new vector<InputId>;
       for (int i = 0; i<repr->fields.size(); i++) 
        { 
        int v = int_neg(repr->fields.at(i).second); 
        ret->push_back(v);
       }
       delete repr;
  return ret;
  }

 

};

class HdividerWatcherStub: public HdividerWorker
{
	char bf[255];
	int bfi; 
 	float bff;
        
        pthread_mutex_t mutex;
        
        
 public:   
         send_channel_t *ch;

		void close() 
		{
			ch->csend("ifs stop"); 
                        ch->close();
		}

		HdividerWatcherStub(hcomm_t *c, string name) 
 		{
                        pthread_mutex_init(&mutex, 0);
 			c->open_ifs<HdividerWatcherStub>(this, name); 
 		} 

		//remote function (#remote) 
		virtual int isFinished() 
		{
                        pthread_mutex_lock(&mutex);
			ch->csend("isFinished");
                        
                        int ret =  RpcServer_fg::int_neg(objrepr_recv(ch, 1));
                        ch->crecv();
                        pthread_mutex_unlock(&mutex);
                        return ret;
                        
		} 
		//End remote function 

		//remote function (#remote) 
		virtual vector<InputId> getInput(int count, string worker_id) 
		{ 
                        pthread_mutex_lock(&mutex);
			ch->csend("getInput");
			objrepr_send(RpcServer_fg::int_gen(count), ch, 1);
			objrepr_send(RpcServer_fg::string_gen(worker_id), ch, 1);
			vector<InputId> ret;
                        vector<InputId> *v;
			v = RpcServer_fg::vec_int_neg(objrepr_recv(ch, 1));
                        ret = *v;
                        delete v;
                        ch->crecv();
                        pthread_mutex_unlock(&mutex);
		return ret;
		} 
		//End remote function 

		//remote function (#remote) 
		virtual void setHandled(InputId input_id) 
		{ 
                        pthread_mutex_lock(&mutex);
			ch->csend("setHandled");
			objrepr_send(RpcServer_fg::int_gen(input_id), ch, 1);
			ch->crecv();
                        pthread_mutex_unlock(&mutex);
		} 
		//End remote function 
                
                //remote function (#remote) 
                virtual int isHandled(InputId input_id)
                {
                        pthread_mutex_lock(&mutex);
                        ch->csend("isHandled");
			objrepr_send(RpcServer_fg::int_gen(input_id), ch, 1);
                        int ret = RpcServer_fg::int_neg(objrepr_recv(ch, 1));
			ch->crecv();
                        pthread_mutex_unlock(&mutex);
                        return ret;
                }
                //End remote function 
                
		//remote function (#remote) 
		virtual void lockResult(InputId result_id, string worker_id) 
		{ 
                        pthread_mutex_lock(&mutex);
			ch->csend("lockResult");
			objrepr_send(RpcServer_fg::int_gen(result_id), ch, 1);
			objrepr_send(RpcServer_fg::string_gen(worker_id), ch, 1);
			ch->crecv();
                        pthread_mutex_unlock(&mutex);
		} 
		//End remote function 

		//remote function (#remote) 
		virtual void unlockResult(InputId result_id, string worker_id) 
		{ 
                        pthread_mutex_lock(&mutex);
			ch->csend("unlockResult");
			objrepr_send(RpcServer_fg::int_gen(result_id), ch, 1);
			objrepr_send(RpcServer_fg::string_gen(worker_id), ch, 1);
			
                                        
                        ch->crecv();
                        pthread_mutex_unlock(&mutex);
		} 
		//End remote function 
                
                virtual void fault(string worker_id)
                {
                
                }

};

// Server skel for RpcServer
class HdividerWatcherSkel : public skel_t
{
	HdividerWatcher *obj;

	char bf[255]; 
 	int bfi; 
 	float bff;
	public: 

	HdividerWatcherSkel(HdividerWatcher *o) { obj = o; }

	virtual char *call(send_channel_t* ch, string &command) 
	{ 
		//remote function (#remote) 
		if (command == "isFinished") 
		{ 
			int ret = obj->isFinished();
			objrepr_send(RpcServer_fg::int_gen(ret), ch, 1);
		return 0;
		} 
		//End remote function 

		//remote function (#remote) 
		if (command == "getInput") 
		{ 
			int count = RpcServer_fg::int_neg(objrepr_recv(ch, 1));
			string worker_id = RpcServer_fg::string_neg(objrepr_recv(ch, 1));
			vector<int64_t> *ret = new vector<int64_t>;
			*ret = obj->getInput( count, worker_id);
                        
			objrepr_send(RpcServer_fg::vec_int_gen(ret), ch, 1);

		return 0;
		} 
		//End remote function 

		//remote function (#remote) 
		if (command == "setHandled") 
		{ 
			int64_t input_id = RpcServer_fg::int_neg(objrepr_recv(ch, 1));
			obj->setHandled( input_id);

		return 0;
		} 
		//End remote function 
                
                //remote function (#remote) 
                if (command == "isHandled")
                {
                        int64_t input_id = RpcServer_fg::int_neg(objrepr_recv(ch, 1));
			int ret = obj->isHandled( input_id);
                        objrepr_send(RpcServer_fg::int_gen(ret), ch, 1);
                return 0;
                }
                //End remote function 
                        
		//remote function (#remote) 
		if (command == "lockResult") 
		{ 
			int64_t result_id = RpcServer_fg::int_neg(objrepr_recv(ch, 1));
			string worker_id = RpcServer_fg::string_neg(objrepr_recv(ch, 1));
			obj->lockResult( result_id, worker_id);
                        
                        
		return 0;
		} 
		//End remote function 

		//remote function (#remote) 
		if (command == "unlockResult") 
		{ 
			int64_t result_id = RpcServer_fg::int_neg(objrepr_recv(ch, 1));
			string worker_id = RpcServer_fg::string_neg(objrepr_recv(ch, 1));
			obj->unlockResult( result_id, worker_id);
                        
                      
		return 0;
		} 
		//End remote function 

	}

 
 };
