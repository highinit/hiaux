
#include "incl.h"
#include "stubgen.h"
#include "basetypegen.h"
//#include "extract_class.h"

ofstream fout;


int subi = 0;
int tabs = 0;
// expression inside vector
char *type_t::invec()
{
	char *bf = new char [255];
	char *bf1 = new char [255];
	strcpy(bf, name);
	tospace('<', bf);
	tospace('>', bf);
	sscanf(bf, "%s %s", bf1, bf1);
	return bf1;
}


//
void stubgen_t::gen(char *classname, char *fname, char *outf)
	{
		read_target(classname, fname);
		fout.open(outf);
        //list_all_types();
		char bf[255];
		cout << "/*\n";
		cout << "Generated by vardist stub generator. Don't change.\n";
		cout << "*/\n";
		cout << "\n";
		cout << "#pragma once\n";
		cout << "#include \"common.h\"\n";
		cout << "#include \"objrepr.h\"\n";
		cout << "#include \"" << fname << "\"\n\n\n";
		//cout << "using namespace funcgen_base; \n\n";
		// print ser functions
		fgclass = new char [255];
		sprintf(fgclass, "%s_fg", classname);
		cout << "class " << fgclass << " \n{\n public: \n\n";
		cout << basetype_gen_funcs;
		repr_gen::init();
		pair<char*, int>* funcs = new pair<char*, int>(new char [1],0);
		for (int i =0; i<type->size(); i++)
		{
			add_to_str(funcs, repr_gen::gen_all(type->at(i)));
		}

		for (int i =0; i<type->size(); i++)
		{
			add_to_str(funcs, repr_gen::neg_all(type->at(i)));
		}

		for (int i = 0; i<funcs->second; i++)
			cout << funcs->first[i];
		cout << "};\n\n";
		//cout << "using namespace funcgen; \n\n";

		// print methods
		tabs++;
		gen_stub(classname);
		tabs++;
		gen_skel(classname);

		fout.close();
	}

//
void stubgen_t::gen_stub(const char *classname)
{
	//cout << "// Client stub for " << classname << "\n";
	char *bf6 = new char [255];
	strcpy(bf6, classname);
	strcat(bf6,"stub_t");
	cout << "class " << bf6 << ": public stub_t\n";
	cout << "{\n	char bf[255];\n	int bfi; \n 	float bff;\n public:   \n\n";
	puttabs(tabs);
	cout << "	void close() \n		{\n		";
	cout << "	ch->csend(\"ifs stop\\n\"); \n		}";
	cout << "\n\n		"<<bf6 << "(hcomm_t *c, char *name) \n 		{" <<
	 "\n 			c->open_ifs<" << bf6 << ">(this, name); \n 		} \n\n";
	delete [] bf6;

	for (int i = 0; i<method.size(); i++)
		{
			tabs++;
			puttabs(tabs);
			cout << "//remote function (#remote) \n";

			puttabs(tabs);

/*			if (stubs)
			{
				cout << "if (!strcmp(command, \"" << method[i]->name << "\\n\")) \n";
				puttabs(tabs);
				cout <<"{ \n";
				tabs++;
			}
			else */
			{
				cout << method[i]->ret << " ";
				if (method[i]->retpointer || !strcmp(method[i]->ret, "char")) cout << "*";
				cout << method[i]->name << "(";
				for (int j = 0; j<method[i]->params.size(); j++)
				{
				cout << method[i]->params[j] << " " << method[i]->names[j];
				if (j!=method[i]->params.size()-1) cout <<", ";
				}
				cout << ") \n";
				puttabs(tabs);
				cout << "{ \n";
				tabs++;
				puttabs(tabs);
				//cout << "send(socket, \"" << method[i]->name << "\\n\", 255, 0);\n";
				cout << "ch->csend(\"" << method[i]->name << "\\n\");\n";
			}

			// GEN METHOD
			method[i]->gen_send_method(NULL, fgclass);

			tabs--;
			cout << "\n";
			puttabs(tabs);
			if (method[i]->retpointer || !strcmp(method[i]->ret,"char"))
				cout << "return ret;\n";
			else
				cout << "return *ret;\n";
			puttabs(tabs);
			cout <<"} \n";
			puttabs(tabs);
			cout << "//End remote function \n\n";
			tabs--;
		}
	tabs--;
	cout << "};\n\n";
}

//
void stubgen_t::gen_skel(const char *classname)
{
	cout << "// Server skel for " << classname << "\n";
	char *bf6 = new char [255];
	strcpy(bf6, classname);
	strcat(bf6,"skel_t");
	cout << "class " << bf6 << " : public skel_t\n{\n	";
	cout << classname << " *obj;\n";
	cout << "\n	char bf[255]; \n 	int bfi; \n 	float bff;\n	public: \n\n";
	puttabs(tabs);
	cout << bf6 << "(" << classname << " *o) { obj = o; }\n\n";
	delete [] bf6;
	puttabs(tabs);
	cout << "virtual char *call(send_channel_t* ch, char *command) \n";
	puttabs(tabs);
	cout <<  "{ \n";

	for (int i = 0; i<method.size(); i++)
		{
			tabs++;
			puttabs(tabs);
			cout << "//remote function (#remote) \n";

			puttabs(tabs);


			cout << "if (!strcmp(command, \"" << method[i]->name << "\\n\")) \n";
			puttabs(tabs);
			cout <<"{ \n";
			tabs++;
            // GEN METHOD
			method[i]->gen_recv_method(NULL, fgclass);

			tabs--;
			cout << "\n";
			puttabs(tabs);
/*			if (method[i]->retpointer || !strcmp(method[i]->ret,"char"))
				cout << "return ret;\n";
			else
				cout << "return *ret;\n";
				*/
			cout << "return 0;\n";
			puttabs(tabs);
			cout <<"} \n";
			puttabs(tabs);
			cout << "//End remote function \n\n";
			tabs--;
		}
	puttabs(tabs);
	cout << "}\n";
	tabs--;
	puttabs(tabs);
	cout << "\n \n };\n";
}

// read class method's args and find their types
void stubgen_t::read_target(char *classname, char *fname)
{

		this->fname = new char [255];
		strcpy(this->fname, fname);

		extracter->setfname(fname);

		char bf[255];
		FILE *f = fopen(fname , "rt");
		fgets(bf, 255, f);
		while (!instring(classname, bf))
		fgets(bf, 255, f);

		// find class
		while (!instring("public:", bf))
		fgets(bf, 255, f);
		fgets(bf, 255, f);

		// { }
		int counter = 0;
		char *bf1;
		while (!instring("};", bf))
		{
			fgets(bf, 255, f);
			// remote method
			if (instring("#remote", bf))
			{
				fgets(bf, 255, f);
				tospace('(',bf);
				tospace(')',bf);
				tospace(';',bf);
				tospace(',',bf);
				removespaces(bf);
			//	movestar(bf);
				bool retpointer = 0;

				backstar(bf);



				bf1 = new char [255];
				firstspace(bf);
				movestar(bf);

				char bfx[255];
				sscanf(bf,"%s", bfx);

				if (isp(bfx)) retpointer = 1;

				// type*
				next(bf, bf1);
				//backstar(bf);
				char *ret = new char [255];
				strcpy(ret, nop(bf1));
				///
				//printf("%s \n",bf1);


				if (!extracter->typexist(nop(ret)))
				{
					// save position

					long seek = ftell(f);
					fclose(f);
					// type*
					if (isp(bf1) && !instring("char*", bf1))
					{
						retpointer = 1;
						//printf("--%s\n", ret);/////////////////////////////
						extracter->find_type(ret, "*ret");

					}
					else if (!isp(bf1))
					{
						extracter->find_type(ret, "ret");

					}
					else
					{
						 retpointer = 1;
						 strcpy(ret,"char");
						 extracter->find_type("char", "ret");
					}
					 // char * / type *
					 // type
					// load position
					f = fopen(fname , "rt");
					fseek(f,seek,SEEK_SET);
				}
			//	list_type(ret);

			//	cout << bf1 << " ";

				bf1 = new char [255];
				firstspace(bf);
				next(bf, bf1);
				/// this
			//	cout << bf1 << " ";
				method_t *m = new method_t(bf1, type);
				m->ret =  ret;
				//if (instring("*", ret))
				m->retpointer = retpointer;
				char *bf2;// = new char [255];
			//	strcpy(bf2,"");
				while(strlen(bf)>4)
				{
				//cout << strlen(bf);
					bf1 = new char [255];
					firstspace(bf);
					next(bf, bf1);
					bf2 = new char [255];
					firstspace(bf);
					next(bf, bf2);

					m->params.push_back(bf1);
					m->names.push_back(bf2);
				/*	if (instring("*",bf1))
					{
						bf1[strlen(bf1)] = '\0';
						cout << bf1 << "-------------";
						break;
						m->ps.push_back(bf2);
					}*/
				///	cout << bf1 << " "
				}
			/*	cout << m->params.size();
				for (int i  =0; i<m->params.size(); i++)
				cout << m->params[i] << " ";
				cout << endl;
			*/
				method.push_back(m);
			}
		//	cout << counter << " " << bf;
		}
		fclose(f);
		for (int i = 0; i<method.size(); i++)
		for (int j = 0; j<method[i]->params.size(); j++)
		{
		extracter->find_type(nop(method[i]->params[j]), method[i]->names[j]);
		}
	/*	for (int i = 0; i<type->size(); i++)
		cout << (*type)[i]->vec << (*type)[i]->name << endl;
*/
}
